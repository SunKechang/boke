---
title: "熟悉又陌生的二进制补码"
date: 2022-12-25
categories: ['Math']
draft: false
---

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>

## 引言

我们都知道二进制补码的规则是正数的补码是他本身，负数的补码是除符号位外所有位取反，然后加1。可是为什么要这样规定呢？为什么不直接使用二进制？如果你有这个疑问，那么这篇文章会告诉你答案。

## 为什么要用补码？

在没有补码的时候，当我们使用二进制表示数字时，假设我们使用4位二进制，那么$0001_2$表示1，$1111_2$则表示$2^4-1$，即15。

而为了使二进制能表示负数，则单独令二进制的最高位为符号位，0表示这个数是正数，1则为负数。那么$0001_2$表示1，$1001_2$表示-1（这里与之后的补码表示方式有所区别）。这里有个问题，既然$0000_2$就能表示0了，那$1000_2$岂不也是表示的0？本着浪费是极大的犯罪的原则，我们就规定$1000_2$表示当前可表示数的最小值-1，即-15。

正当我们要撸起袖子开始干的时候，又有人本着浪罪的原则来了，他说，目前数是能表示了，可是不好运算啊。加法还好算，减法怎么办？能不能直接用加法代替减法？举个🌰，2-3=-1，在4位的二进制中，2表示为$0010_2$，3则是$0011_2$，考虑到2-3=2+(-3)，那么将3转换为-3，即$1011_2$。$0010_2$ + $1011_2$ = $1101_2$。这个结果好像和我们的预期$1001_2$有所差距。这时我们就引入了补码的概念。2的补码是$0010_2$，-3的补码是$1101_2$，$0010_2$ + $1101_2$ = $1111_2$。而这个结果正好是-1的补码。这里还可以再举一些例子。

| 加数1 | 加数 | 加数1二进制补码 | 加数2二进制补码 | 计算结果 | 预期 |
|--|--|---|---|---|--|
| 7 | -8 | 0111 | 1000 | 1111=-1 | -1 |
|-7 | -6 | 1001 | 1010 | 0011=3 | -13 |
| 5 | 4 | 0101 | 0100 | 1001 = -7 | 9 |

可以看到，当计算结果在可表示范围内时，补码计算的结果是正确的。对于超出范围的情况我们先按下不表，单表这个补码是怎么解决掉减法的问题的， **其实补码合理地运用了最高位溢出的情况。也就是当1111再加1时会回到0000，这样就形成了类似于钟表的循环结构。** 借助下图，我们可以看到，想让2-3=-1，要么从2的位置向后退3格回到-1，这是减法的思路，要么向前走13格，而-3对应的补码1101就等于13(8+4+1)，这其实就是补码的思路。

![钟表结构的二进制补码](/images/two's%20complement-1.jpg)

花开两朵，各表一枝，再说前面表中超过可表示范围的情况：-7+(-6)。我们把他们放到图上就能看出，-7所在的位置是1001，-6在1010，他们相加也就是从-7的位置向前走$10(1010_2=8+2$)格，正好到了3的位置。这也就解释了为什么计算机得出的结果是3了。

之前总是死记从原码到补码的转换规律，其实仔细观察一下会发现原码和补码之间也是有数学关系的。
对于$w$位的向量$\vec{x}=[x_{w-1}, x_{w-2}, ..., x_0]$，当用作二进制补码时表示的数为：

$B2Tw(\vec{x})= −x_{w-1}2^{w-1} + \sum\nolimits_{i=0}^{w-2}x_i2^i$

简单来说，就是如果符号位是1，则结果为其他位二进制表示的无符号数减去$2^{w-1}$，如果符号位为0，则结果就是其他位二进制表示的无符号数。