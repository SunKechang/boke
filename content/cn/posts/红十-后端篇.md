---
title: "红十（后端篇）"
date: 2023-03-21
categories: ['Application']
draft: false
---

## 引言

因为自己最近花一个月做了一个类斗地主游戏(http://redten.fun)，所以想写些文章来介绍一下这个实时对局游戏的代码框架。相应的文章共有两篇。我会从前端和后端两方面展开介绍，由于我先写了后端，所以第一篇文章从后端讲起。如果你也苦于市面上没有你家乡特色的扑克游戏，想自己开发一个，那就读下去吧。

## 游戏规则

红十的规则在百度百科有介绍（https://baike.baidu.com/item/%E7%BA%A2%E5%8D%81/2145065?fr=aladdin#2）， 我这里要做的是四人游戏，规则和百科中介绍的很相似，不过他去掉了一些牌，而我用的是一整套牌。简短截说，咱们开始说代码。

## 整体框架

由于棋牌类游戏需要服务端向客户端推送关于牌的相关信息，所以需要一个全双工的通信方式，于是在框架上我选择了`Gin`+`WebSocket`。

敲定框架，开始写业务。为了能实现一个牌局的摸牌、出牌等操作，我用了简单好用的模拟法。现实中要组一个牌局，首先得有一个屋子，张三想打牌所以进入房间，然后开始联系其他牌友一起进入房间，人数满四个人就可以开始。

为了模拟这个过程，我写了一个`Client`类，表示每一个玩家；写了一个`Room`类，表示张三进去的屋子，屋子保存了当前在线的玩家和牌局的状态（等待、摸牌、出牌）。还有一个`Hub`类，作为单例，每个新来的用户和新开的房间都得到`Hub`上登记，相当于所有打牌的人都在一个酒店中，而这个`Hub`就是酒店前台的账本，他的作用就是防止有不打牌只闹事的人进来💀。

看到这里，如果你真的想写，那你就可以去写了，慢慢处理业务上的复杂场景。但我这里还有一些对游戏的认识，或许你可以在困惑的时候看一看😉。

## 三个机制

由于第一次做实时游戏，还是有很多不曾碰到的BUG的，这些BUG也让我增加了对一些概念的认识，我就来唠唠吧。

### 锁机制&CAS

游戏后端通常要存储一些玩家对局实时数据，并要对这些数据进行修改，所以多线程的数据安全是个值得好好设计的问题。

在我的游戏中有这样一个场景：玩家在出牌阶段不停出牌，直到手牌为0，当手牌为0时更新玩家的当前状态从`游戏中`变为`走人`。
假设当前4个人都有手牌，张三出一张`大王`，如果你没有比`大王`还大的牌，则只能跳过当前出牌阶段，如果没人比张三的`大王`大，即在轮询3个人后都不出牌，则自动进入下一轮，下一轮张三可以出任意牌了。

那么问题来了，如果有一个人状态是`走人`，也就是说只有3个人有手牌，那在轮询2个人都不出牌后就会自动进入下一轮。所以我要维护当前状态为`游戏中`的人数`onGamePlayerNum`。当有一个玩家手牌变为0后，`onGamePlayerNum`自动减一。而如果两个玩家几乎同时状态由`游戏中`变为`走人`，则很有可能`onGamePlayerNum`的数量只减一。这等同于100个线程对同一个变量做减一操作，最终变量很可能没有减100。

为了解决这个问题，我们要么使用锁，要么使用CAS，而这里显然冲突的概率并不高，所以为了节约资源我们使用CAS来操作效果会更好。

而对于一些冲突概率高或者并不是对一个变量进行更改的情况，用锁就是唯一的选择了。

### 心跳机制&看门狗机制

上文讲到用到了`WebSocket`，在最开始我错误理解了他的全双工概念，误以为他会自己帮我维护这样一个连接，真正实践后才发现，Golang中的`Gorilla Websocket`设置了超时时间，也就是说超过一定时间没有读写操作这个连接就会断掉。官网是这样说的：
```Golang
func (c *Conn) SetWriteDeadline(t time.Time) error
```
> SetWriteDeadline sets the write deadline on the underlying network connection. After a write has timed out, the websocket state is corrupt and all future writes will return an error. A zero value for t means writes will not time out.

```Golang
func (*Conn) SetReadDeadline
```

> SetReadDeadline sets the read deadline on the underlying network connection. After a read has timed out, the websocket connection state is corrupt and all future reads will return an error. A zero value for t means reads will not time out.


因此要么为应用设计心跳模式，保证读和写都不超时，要么不设置超时时间。两种方式各有利弊，前者只需要一个看门狗来检测WebSocket连接是否正常，不正常就可以回收，代价是心跳会带来些许资源消耗；后者则需要自己设计连接无效的逻辑。

我选择了前者，因为相应的资源消耗在我可接受范围内，但主要是因为不需要自己写连接无效的逻辑。

### 异步机制

在涉及到多人实时的应用中，我们很难保证所有用户的状态都正常，因此在一些需要向用户发送消息的场景中，我们都要把它做成异步，来保证主线程不被阻塞。Golang中网络异步就比简单了，加上关键词`go`就好了。

如果你也是Gopher，对于写实时游戏有些困惑，可以来聊聊。📨1437821834@qq.com ☕